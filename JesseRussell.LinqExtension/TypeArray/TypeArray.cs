//This code was generated by TypeArrayGenerate.py
using System;
using System.Collections;
using System.Collections.Generic;
namespace ExtendedTyping
{
    public struct TypeArray<T0> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 1;
        public static implicit operator Type[](TypeArray<T0> ta) => new Type[] {typeof(T0) };
    }
    public struct TypeArray<T0, T1> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 2;
        public static implicit operator Type[](TypeArray<T0, T1> ta) => new Type[] {typeof(T0), typeof(T1) };
    }
    public struct TypeArray<T0, T1, T2> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 3;
        public static implicit operator Type[](TypeArray<T0, T1, T2> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2) };
    }
    public struct TypeArray<T0, T1, T2, T3> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 4;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 5;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 6;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 7;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 8;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 9;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 10;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 11;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 12;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 13;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 14;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 15;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 16;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 17;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 18;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 19;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 20;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 21;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 22;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 23;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 24;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 25;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 26;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 27;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
            yield return typeof(T27);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    case 27: return typeof(T27);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 28;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26), typeof(T27) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
            yield return typeof(T27);yield return typeof(T28);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    case 27: return typeof(T27);case 28: return typeof(T28);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 29;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26), typeof(T27), typeof(T28) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
            yield return typeof(T27);yield return typeof(T28);yield return typeof(T29);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    case 27: return typeof(T27);case 28: return typeof(T28);case 29: return typeof(T29);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 30;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26), typeof(T27), typeof(T28), typeof(T29) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
            yield return typeof(T27);yield return typeof(T28);yield return typeof(T29);
            yield return typeof(T30);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    case 27: return typeof(T27);case 28: return typeof(T28);case 29: return typeof(T29);
                    case 30: return typeof(T30);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 31;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26), typeof(T27), typeof(T28), typeof(T29), typeof(T30) };
    }
    public struct TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31> : ITypeArray
    {
        public IEnumerator<Type> GetEnumerator()
        {
            yield return typeof(T0);yield return typeof(T1);yield return typeof(T2);
            yield return typeof(T3);yield return typeof(T4);yield return typeof(T5);
            yield return typeof(T6);yield return typeof(T7);yield return typeof(T8);
            yield return typeof(T9);yield return typeof(T10);yield return typeof(T11);
            yield return typeof(T12);yield return typeof(T13);yield return typeof(T14);
            yield return typeof(T15);yield return typeof(T16);yield return typeof(T17);
            yield return typeof(T18);yield return typeof(T19);yield return typeof(T20);
            yield return typeof(T21);yield return typeof(T22);yield return typeof(T23);
            yield return typeof(T24);yield return typeof(T25);yield return typeof(T26);
            yield return typeof(T27);yield return typeof(T28);yield return typeof(T29);
            yield return typeof(T30);yield return typeof(T31);
        }
        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
        public Type this[int i]
        {
            get
            {
                switch (i)
                {
                    case 0: return typeof(T0);case 1: return typeof(T1);case 2: return typeof(T2);
                    case 3: return typeof(T3);case 4: return typeof(T4);case 5: return typeof(T5);
                    case 6: return typeof(T6);case 7: return typeof(T7);case 8: return typeof(T8);
                    case 9: return typeof(T9);case 10: return typeof(T10);case 11: return typeof(T11);
                    case 12: return typeof(T12);case 13: return typeof(T13);case 14: return typeof(T14);
                    case 15: return typeof(T15);case 16: return typeof(T16);case 17: return typeof(T17);
                    case 18: return typeof(T18);case 19: return typeof(T19);case 20: return typeof(T20);
                    case 21: return typeof(T21);case 22: return typeof(T22);case 23: return typeof(T23);
                    case 24: return typeof(T24);case 25: return typeof(T25);case 26: return typeof(T26);
                    case 27: return typeof(T27);case 28: return typeof(T28);case 29: return typeof(T29);
                    case 30: return typeof(T30);case 31: return typeof(T31);
                    default: throw new IndexOutOfRangeException();
                }
            }
        }
        public int Length => 32;
        public static implicit operator Type[](TypeArray<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31> ta) => new Type[] {typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19), typeof(T20), typeof(T21), typeof(T22), typeof(T23), typeof(T24), typeof(T25), typeof(T26), typeof(T27), typeof(T28), typeof(T29), typeof(T30), typeof(T31) };
    }
}